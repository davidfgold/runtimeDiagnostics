import numpy as np
from matplotlib import pyplot as plt
import mpl_toolkits.mplot3d.axes3d as p3
import matplotlib.animation as animation

"""

Functions for reading and plotting runtime data for the Borg MOEA

By: D. Gold
Date: 5/20

"""


def read_runtime(file, total_NFE, runtime_freq, num_obj):
    """

    Reads a runtime file generated by the Borg MOEA and
    returns a dictionary with the following keys:
        NFE - number of NFEs at each snapshot
        Elapsed_time - wallclock time of snapshot
        SBX - SBX operator probabiity at snapshot
        DE - DE operator probabiity at snapshot
        PCX - PCX operator probabiity at snapshot
        SPX - SPX operator probabiity at snapshot
        UNDX - UNDX operator probabiity at snapshot
        UM - UM operator probabiity at snapshot
        Improvements - cumulative archive additions
        Restarts - number of restarts by snapshot
        Population Size - size of population
        Archive Size - size of archive
        Mutation Index - tracks mutations
        Objectives - Archive set objectives


    Parameter file: a string with the name of a runtime file
    Parameter total_NFE: total NFE for the MOEA run
    Parameter runtime_freq: frequency of runtime output in NFE
    Parameter num_obj: number of objectives in optimization

    """

    runtime = open(file)
    all_lines = runtime.readlines()
    runtime.close()
    
    # initalize arrays to store runtime info
    NFE = np.zeros(int(total_NFE/runtime_freq))
    Elapsed_time = np.zeros(int(total_NFE/runtime_freq))
    SBX = np.zeros(int(total_NFE/runtime_freq))
    DE = np.zeros(int(total_NFE/runtime_freq))
    PCX = np.zeros(int(total_NFE/runtime_freq))
    SPX = np.zeros(int(total_NFE/runtime_freq))
    UNDX = np.zeros(int(total_NFE/runtime_freq))
    UM = np.zeros(int(total_NFE/runtime_freq))
    improvements = np.zeros(int(total_NFE/runtime_freq))
    restarts = np.zeros(int(total_NFE/runtime_freq))
    pop_size = np.zeros(int(total_NFE/runtime_freq))
    archive_size = np.zeros(int(total_NFE/runtime_freq))
    mutation_idx = np.zeros(int(total_NFE/runtime_freq))
    all_obj_snapshots = []
    all_DV_snapshots = []
    NFE_counter = 0
    
    
    for i in range(0, len(all_lines)):
        if all_lines[i][2:5] == 'NFE':
            NFE[NFE_counter] = float(all_lines[i][6:-1])
            Elapsed_time[NFE_counter] = float(all_lines[i+1][14:-1])
            SBX[NFE_counter] = float(all_lines[i+2][6:-1])
            DE[NFE_counter] = float(all_lines[i+3][5:-1])
            PCX[NFE_counter] = float(all_lines[i+4][6:-1])
            SPX[NFE_counter] = float(all_lines[i+5][6:-1])
            UNDX[NFE_counter] = float(all_lines[i+6][7:-1])
            UM[NFE_counter] = float(all_lines[i+7][5:-1])
            improvements[NFE_counter] = float(all_lines[i+8][15:-1])
            restarts[NFE_counter] = float(all_lines[i+9][11:-1])
            pop_size[NFE_counter] = float(all_lines[i+10][17:-1])
            archive_size[NFE_counter] = float(all_lines[i+11][14:-1])
            mutation_idx[NFE_counter] = float(all_lines[i+12][16:-1])
            
            NFE_counter +=1
            
            # extract objectives
            start_set = i + 13
            current_line = start_set
            while all_lines[current_line][0] != '#':
                current_line += 1
            raw_snapshot = all_lines[start_set:current_line-1] 
            snapshot = []
            snapshot.append([j.split() for j in raw_snapshot])
            snapshot = snapshot[0]
            #obj_snapshots = []
            #DV_snapshots = []
            obj_snapshots = np.zeros([current_line-start_set-1, num_obj])
            for k in range(0, len(snapshot)):
                for j in range(0, num_obj):
                    obj_snapshots[k,j] = snapshot[k][-num_obj+j]
                
                #obj_snapshots.append([j.split() for j in 
                 #                              snapshot[k][-num_obj:]])
                
                #DV_snapshots.append(np.array([j.split() for j in snapshot[k][:-num_obj]]))
            
            all_obj_snapshots.append(obj_snapshots)
            #all_DV_snapshots.append(DV_snapshots)
    
    runtime_output = {'NFE': NFE,
                      'Elapsed Time': Elapsed_time,
                      'SBX': SBX,
                      'DE': DE,
                      'PCX': PCX,
                      'SPX': SPX,
                      'UNDX': UNDX,
                      'UM': UM,
                      'Improvements': improvements,
                      'Restarts': restarts,
                      'Population Size': pop_size,
                      'Archive Size': archive_size,
                      'Mutation Index': mutation_idx,
                      'Objectives': all_obj_snapshots}
    
    return runtime_output


def plot_text(ax, problem, num_obj, freq, i):
    """

    Plots text in one subplot with summary information


    Parameter ax: a Matplotlib subplot
    Parameter probem: name of the problem (string)
    Parameter num_objectives: number of objectives
    Parameter freq: frequency of runtime output
    Parameter i: snapshot number

    """
    ax.text(0, 4, 'Runtime Diagnostic Dashboard', fontsize=28)
    ax.text(0, 3.5, 'Problem: ' + problem, fontsize=24)
    ax.text(0, 3, 'Num obj: ' + str(num_obj), fontsize=24)
    ax.text(0, 2, 'Current NFE: ' + str(i*freq), fontsize=24)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.grid(False)
    ax.axis('off')
    ax.set_ylim([0,4])


def plot_3Dscatter(ax, objectives, i):
    """

    Plots a scatter 3D plot of objectives


    Parameter ax: a Matplotlib subplot
    Parameter objectives: a numpy array of objectives
    Parameter i: snapshot number

    """

    ax.scatter(objectives[i][:,0], objectives[i][:,1], objectives[i][:,2], color='b', alpha=.8)
    ax.view_init(25, 10)
    ax.set_xticks([0, 1, 2])
    ax.set_yticks([0, 1, 2])
    ax.set_zticks([0, 1, 2])
    ax.set_xlim([0,2])
    ax.set_ylim([0,2])
    ax.set_zlim([0,2])
    ax.set_xlabel('Obj 1 $\longrightarrow$')
    ax.set_ylabel('$\longleftarrow$ Obj 2')
    ax.set_zlabel('Obj 3 $\longrightarrow$')


def plot_operators(ax, runtime, total_NFE, i):
    """

    Plots a line plot of operator probabilities vs. NFE


    Parameter ax: a Matplotlib subplot
    Parameter runtime: a dict storing runtime information
    Parameter total_NFE: total NFE for the MOEA run
    Parameter i: snapshot number

    """

    ax.plot(runtime['NFE'][:i], runtime['SBX'][:i], color='blue')
    ax.plot(runtime['NFE'][:i], runtime['DE'][:i], color='orange')
    ax.plot(runtime['NFE'][:i], runtime['PCX'][:i], color='green')
    ax.plot(runtime['NFE'][:i], runtime['SPX'][:i], color='red')
    ax.plot(runtime['NFE'][:i], runtime['UNDX'][:i], color='purple')
    ax.plot(runtime['NFE'][:i], runtime['UM'][:i], color='yellow')

    ax.set_xlim(0,total_NFE)
    ax.set_ylim(0, 1)
    ax.set_xlabel('NFE')
    ax.set_ylabel('Operator Probability')
    ax.legend(['SBX', 'DE', 'PCX', 'SPX', 'UNDX', 'UM'], loc='upper left', ncol=3)


def plot_metric(ax, metric, metric_name, NFE, total_NFE, ymax, i):
    """

    Plots a line plot of HV vs. NFE


    Parameter ax: a Matplotlib subplot
    Parameter metric: a numpy array of the performance metric
    Parameter NFE: a numpy array of NFE corresponding to HVs
    Parameter total_NFE: total NFE for the MOEA run
    Parameter ymax: max y-axis value
    Parameter i: snapshot number

    """

    ax.plot(NFE[:i], metric[:i], c='b')
    ax.set_xlim([0, total_NFE])
    ax.set_ylim([0, ymax])
    ax.set_ylabel(metric_name)


def plot_paxis(ax, objs, i):
    """

    Plots a parallel axis plot of objectives


    Parameter ax: a Matplotlib subplot
    Parameter objs: a numpy array of objectives
    Parameter i: snapshot number

    """

    for j in range(len(objs[i][:,0])):
        ys = objs[i][j,:]
        xs = range(len(ys))
        ax.plot(xs, ys, c='b', alpha=.8, linewidth=.5)

    ax.set_ylabel('Objective val \n $\longleftarrow$ Preference', size=12)
    ax.set_ylim([0,2])
    ax.set_xticks([0,1,2])
    ax.set_xticklabels(['Obj 1', 'Obj 2', 'Obj 3'], fontsize=12)
    ax.set_xlim([0, len(objs[i][0,:])-1])





